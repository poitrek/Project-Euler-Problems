# Problem no. 39: Integer right triangles
###### SOLVED ######

'''
Approach of the solution:
Every pythagorean triple that follows the identity
a^2 + b^2 = c^2
where GCF(a,b,c) = 1, can be generated by formulas
a = x^2 - y^2, b = 2x*y, c = x^2 + y^2
where x, y are mutually prime numbers, x > y, one of them
is odd, and the other one is even.
Then the sum of the triple equals
2x^2 + 2xy = 2x(x+y)
All the other triples can be expressed as multiplications of
the triples defined above, respectively k*a, k*b, k*c, where
k is a natural number.
'''

import numpy as np

import time
class Timer:
    _start_time = None
    @classmethod
    def start_measure_time(cls):
        cls._start_time = time.perf_counter()

    @classmethod
    def print_time_elapsed(cls):
        time_elapsed = time.perf_counter() - cls._start_time
        print('Time elapsed: {:.3f} s'.format(time_elapsed))

# Global array of primes
primes = [2, 3, 5]

# Fills the global array of prime numbers with primes less or equal N
def find_primes(N):
    start = primes[-1] + 2
    for c in range(start, N+1, 2):
        c_sqrt = np.sqrt(c)
        i = 0
        # Iterate until we pass square root of c or find a divider of c
        while primes[i] <= c_sqrt and c % primes[i] != 0:
            i += 1
        # If the loop ended without finding a divider of c and surpassing square root of c
        if primes[i] > c_sqrt:
            primes.append(c)


if __name__ == '__main__':

    Timer.start_measure_time()

    find_primes(1000)

    # Array of numbers of triples that sum up to specific value
    # triple_sums[i] stores number of pythagorean triples which sum up to i*2
    n_triple_sums = [0] * 501

    core_triple_sums = []

    # First generate "root" triples, where a, b, c are mutually prime

    # 24 was enough counter to exceed 1000 with the sum of the triple
    for x in range(1, 24):
        # Find prime factors of x (exclude 2)
        i, i_prime = 1, 3
        x_prime_factors = []
        while i_prime < x:
            if x % i_prime == 0:
                x_prime_factors.append(i_prime)
            i += 1
            i_prime = primes[i]
        for y in range((x % 2) + 1, x + 1, 2):
            # a = x^2-y^2, b = 2*x*y, c = x^2+y^2
            # a + b + c = 2*x*(x+y)
            # HALF of the sum of triple
            xy_sum = x * (x + y)
            if xy_sum > 500:
                break
            # Find out if x and y are coprimes
            is_coprime = True
            for fact in x_prime_factors:
                if y % fact == 0:
                    is_coprime = False
                    break
            if is_coprime:
                # print('Triple for x={}, y={}:'.format(x, y))
                # print('({}, {}, {}) sum = {}'.format(x*x-y*y, 2*x*y, x*x+y*y, 2*x*(x+y)))
                n_triple_sums[xy_sum] += 1
                core_triple_sums.append(xy_sum)

    # print('triple_sums:')
    # print(n_triple_sums)
    # print('core sums:')
    # print(core_triple_sums)

    # Now generate all of multiplied triple sums of the core sums

    for tr_sum in core_triple_sums:
        m_sum = 2 * tr_sum
        while m_sum <= 500:
            n_triple_sums[m_sum] += 1
            m_sum += tr_sum

    # print(n_triple_sums)
    print('Maximum number of pythagorean triples sum up to:')
    print(2 * np.argmax(n_triple_sums))
    print('- {} triples'.format(np.max(n_triple_sums)))

    Timer.print_time_elapsed()
